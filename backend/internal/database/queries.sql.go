// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const deleteJobItemsByJob = `-- name: DeleteJobItemsByJob :exec
DELETE FROM job_items WHERE job_id = $1
`

func (q *Queries) DeleteJobItemsByJob(ctx context.Context, jobID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteJobItemsByJob, jobID)
	return err
}

const getAllJobs = `-- name: GetAllJobs :many
SELECT id, job_number, job_name FROM jobs ORDER BY job_number
`

type GetAllJobsRow struct {
	ID        uuid.UUID `json:"id"`
	JobNumber string    `json:"job_number"`
	JobName   string    `json:"job_name"`
}

func (q *Queries) GetAllJobs(ctx context.Context) ([]GetAllJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllJobsRow
	for rows.Next() {
		var i GetAllJobsRow
		if err := rows.Scan(&i.ID, &i.JobNumber, &i.JobName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChildrenWithPayApps = `-- name: GetChildrenWithPayApps :many
SELECT
    ji.id,
    ji.item_number,
    ji.qty AS total_qty,
    ji.unit_price,
    COALESCE(pa.qty, '0')::TEXT AS pay_app_qty,
    COALESCE(pac.cumulative_qty, '0')::TEXT AS cumulative_qty,
    COALESCE(pac.previous_cumulative_qty, '0')::TEXT AS previous_cumulative_qty
FROM job_items ji
LEFT JOIN pay_applications pa ON ji.id = pa.job_item_id AND pa.pay_app_month = $2
LEFT JOIN pay_application_cumulative pac ON ji.id = pac.job_item_id AND pac.pay_app_month = $2
WHERE ji.parent_id = $1
`

type GetChildrenWithPayAppsParams struct {
	ParentID    uuid.NullUUID `json:"parent_id"`
	PayAppMonth time.Time     `json:"pay_app_month"`
}

type GetChildrenWithPayAppsRow struct {
	ID                    uuid.UUID `json:"id"`
	ItemNumber            string    `json:"item_number"`
	TotalQty              string    `json:"total_qty"`
	UnitPrice             string    `json:"unit_price"`
	PayAppQty             string    `json:"pay_app_qty"`
	CumulativeQty         string    `json:"cumulative_qty"`
	PreviousCumulativeQty string    `json:"previous_cumulative_qty"`
}

// Fetches children of a parent along with their pay_app data for a specific month
func (q *Queries) GetChildrenWithPayApps(ctx context.Context, arg GetChildrenWithPayAppsParams) ([]GetChildrenWithPayAppsRow, error) {
	rows, err := q.db.QueryContext(ctx, getChildrenWithPayApps, arg.ParentID, arg.PayAppMonth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChildrenWithPayAppsRow
	for rows.Next() {
		var i GetChildrenWithPayAppsRow
		if err := rows.Scan(
			&i.ID,
			&i.ItemNumber,
			&i.TotalQty,
			&i.UnitPrice,
			&i.PayAppQty,
			&i.CumulativeQty,
			&i.PreviousCumulativeQty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCostPerformanceIndex = `-- name: GetCostPerformanceIndex :many
WITH job_info AS (
    SELECT id, job_number, contract_value
    FROM jobs
    WHERE job_number = $1
),
total_scheduled AS (
    -- Sum of all scheduled quantities and calculated values (only leaf items with qty > 0)
    SELECT
        SUM(ji.qty) AS total_qty,
        SUM(ji.qty * ji.unit_price) AS total_contract_value
    FROM job_items ji
    JOIN job_info j ON ji.job_id = j.id
    WHERE ji.qty > 0
),
budget_value AS (
    -- Use contract_value if set, otherwise fall back to sum of qty * unit_price
    SELECT COALESCE(j.contract_value, ts.total_contract_value, 0) AS budget
    FROM job_info j
    CROSS JOIN total_scheduled ts
),
monthly_cumulative_qty AS (
    -- Cumulative quantity billed per month
    SELECT
        pa.pay_app_month AS month,
        SUM(pa.qty) AS month_qty,
        SUM(SUM(pa.qty)) OVER (ORDER BY pa.pay_app_month) AS cumulative_qty
    FROM pay_applications pa
    JOIN job_items ji ON pa.job_item_id = ji.id
    JOIN job_info j ON ji.job_id = j.id
    GROUP BY pa.pay_app_month
),
monthly_costs AS (
    SELECT
        DATE_TRUNC('month', transaction_date)::DATE AS month,
        SUM(amount) AS cost_total
    FROM job_cost_ledger
    WHERE job = $1
      AND transaction_type IN ('AP cost', 'JC cost', 'PR cost')
      AND transaction_date IS NOT NULL
    GROUP BY DATE_TRUNC('month', transaction_date)
)
SELECT
    mcq.month,
    COALESCE(bv.budget, 0)::BIGINT AS budget,
    COALESCE(ts.total_qty, 0)::TEXT AS total_scheduled_qty,
    mcq.cumulative_qty::TEXT AS cumulative_qty,
    CASE
        WHEN COALESCE(ts.total_qty, 0) > 0
        THEN ROUND((mcq.cumulative_qty / ts.total_qty) * 100, 2)::TEXT
        ELSE '0'
    END AS percent_complete,
    CASE
        WHEN COALESCE(ts.total_qty, 0) > 0 AND COALESCE(bv.budget, 0) > 0
        THEN ROUND((mcq.cumulative_qty / ts.total_qty) * bv.budget, 2)::BIGINT
        ELSE 0::BIGINT
    END AS earned_value,
    COALESCE(SUM(mc.cost_total) OVER (ORDER BY mcq.month), 0)::BIGINT AS actual_cost,
    CASE
        WHEN COALESCE(SUM(mc.cost_total) OVER (ORDER BY mcq.month), 0) > 0
             AND COALESCE(ts.total_qty, 0) > 0
             AND COALESCE(bv.budget, 0) > 0
        THEN ROUND(
            ((mcq.cumulative_qty / ts.total_qty) * bv.budget) /
            SUM(mc.cost_total) OVER (ORDER BY mcq.month),
            2
        )::TEXT
        ELSE '0'
    END AS cpi
FROM monthly_cumulative_qty mcq
CROSS JOIN budget_value bv
CROSS JOIN total_scheduled ts
LEFT JOIN monthly_costs mc ON mc.month = mcq.month
ORDER BY mcq.month
`

type GetCostPerformanceIndexRow struct {
	Month             time.Time `json:"month"`
	Budget            int64     `json:"budget"`
	TotalScheduledQty string    `json:"total_scheduled_qty"`
	CumulativeQty     string    `json:"cumulative_qty"`
	PercentComplete   string    `json:"percent_complete"`
	EarnedValue       int64     `json:"earned_value"`
	ActualCost        int64     `json:"actual_cost"`
	Cpi               string    `json:"cpi"`
}

// Fetches monthly CPI data: Earned Value / Actual Costs
// Earned Value = (cumulative qty / total qty) * original budget
// Falls back to sum of scheduled_value if contract_value is not set
func (q *Queries) GetCostPerformanceIndex(ctx context.Context, jobNumber string) ([]GetCostPerformanceIndexRow, error) {
	rows, err := q.db.QueryContext(ctx, getCostPerformanceIndex, jobNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCostPerformanceIndexRow
	for rows.Next() {
		var i GetCostPerformanceIndexRow
		if err := rows.Scan(
			&i.Month,
			&i.Budget,
			&i.TotalScheduledQty,
			&i.CumulativeQty,
			&i.PercentComplete,
			&i.EarnedValue,
			&i.ActualCost,
			&i.Cpi,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDirectChildren = `-- name: GetDirectChildren :many
SELECT
    id,
    parent_id,
    item_number,
    description,
    budget,
    qty,
    unit_price,
    scheduled_value
FROM job_items
WHERE parent_id = $1
`

type GetDirectChildrenRow struct {
	ID             uuid.UUID     `json:"id"`
	ParentID       uuid.NullUUID `json:"parent_id"`
	ItemNumber     string        `json:"item_number"`
	Description    string        `json:"description"`
	Budget         string        `json:"budget"`
	Qty            string        `json:"qty"`
	UnitPrice      string        `json:"unit_price"`
	ScheduledValue string        `json:"scheduled_value"`
}

// Fetches direct children of a parent item (for validation)
func (q *Queries) GetDirectChildren(ctx context.Context, parentID uuid.NullUUID) ([]GetDirectChildrenRow, error) {
	rows, err := q.db.QueryContext(ctx, getDirectChildren, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDirectChildrenRow
	for rows.Next() {
		var i GetDirectChildrenRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.ItemNumber,
			&i.Description,
			&i.Budget,
			&i.Qty,
			&i.UnitPrice,
			&i.ScheduledValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobByNumber = `-- name: GetJobByNumber :one
SELECT id, job_number, job_name FROM jobs WHERE job_number = $1
`

type GetJobByNumberRow struct {
	ID        uuid.UUID `json:"id"`
	JobNumber string    `json:"job_number"`
	JobName   string    `json:"job_name"`
}

func (q *Queries) GetJobByNumber(ctx context.Context, jobNumber string) (GetJobByNumberRow, error) {
	row := q.db.QueryRowContext(ctx, getJobByNumber, jobNumber)
	var i GetJobByNumberRow
	err := row.Scan(&i.ID, &i.JobNumber, &i.JobName)
	return i, err
}

const getJobCostLedgerByJob = `-- name: GetJobCostLedgerByJob :many
SELECT id, job, phase, cat, transaction_type, transaction_date, amount, created_at
FROM job_cost_ledger
WHERE job = $1
ORDER BY transaction_date
`

// Fetches all job cost ledger entries for a specific job
func (q *Queries) GetJobCostLedgerByJob(ctx context.Context, job string) ([]JobCostLedger, error) {
	rows, err := q.db.QueryContext(ctx, getJobCostLedgerByJob, job)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobCostLedger
	for rows.Next() {
		var i JobCostLedger
		if err := rows.Scan(
			&i.ID,
			&i.Job,
			&i.Phase,
			&i.Cat,
			&i.TransactionType,
			&i.TransactionDate,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobTree = `-- name: GetJobTree :many
WITH RECURSIVE job_tree AS (
    -- 1. Anchor: Select Roots (Items with no parent)
    -- We alias the table as 'root' to prevent ambiguity errors
    SELECT 
        root.id, 
        root.job_id, 
        root.parent_id, 
        root.sort_order, 
        root.item_number, 
        root.description,
        root.scheduled_value, 
        root.budget, 
        root.job_cost_id, 
        root.qty, 
        root.unit, 
        root.unit_price,
        1 AS depth,
        ARRAY[root.sort_order] AS path_order
    FROM job_items root
    WHERE root.job_id = $1 AND root.parent_id IS NULL

    UNION ALL

    -- 2. Recursion: Join Children to Parents
    SELECT 
        c.id, 
        c.job_id, 
        c.parent_id, 
        c.sort_order, 
        c.item_number, 
        c.description,
        c.scheduled_value, 
        c.budget, 
        c.job_cost_id, 
        c.qty, 
        c.unit, 
        c.unit_price,
        p.depth + 1,
        p.path_order || c.sort_order
    FROM job_items c
    JOIN job_tree p ON c.parent_id = p.id
)
SELECT id, job_id, parent_id, sort_order, item_number, description, scheduled_value, budget, job_cost_id, qty, unit, unit_price, depth, path_order FROM job_tree
ORDER BY path_order
`

type GetJobTreeRow struct {
	ID             uuid.UUID      `json:"id"`
	JobID          uuid.UUID      `json:"job_id"`
	ParentID       uuid.NullUUID  `json:"parent_id"`
	SortOrder      int32          `json:"sort_order"`
	ItemNumber     string         `json:"item_number"`
	Description    string         `json:"description"`
	ScheduledValue string         `json:"scheduled_value"`
	Budget         string         `json:"budget"`
	JobCostID      sql.NullString `json:"job_cost_id"`
	Qty            string         `json:"qty"`
	Unit           sql.NullString `json:"unit"`
	UnitPrice      string         `json:"unit_price"`
	Depth          int32          `json:"depth"`
	PathOrder      interface{}    `json:"path_order"`
}

// 3. Sort by the array path to recreate Excel structure
func (q *Queries) GetJobTree(ctx context.Context, jobID uuid.UUID) ([]GetJobTreeRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobTree, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobTreeRow
	for rows.Next() {
		var i GetJobTreeRow
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.ParentID,
			&i.SortOrder,
			&i.ItemNumber,
			&i.Description,
			&i.ScheduledValue,
			&i.Budget,
			&i.JobCostID,
			&i.Qty,
			&i.Unit,
			&i.UnitPrice,
			&i.Depth,
			&i.PathOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyPerformance = `-- name: GetMonthlyPerformance :many
WITH monthly_costs AS (
    SELECT
        DATE_TRUNC('month', jcl.transaction_date)::DATE AS month,
        SUM(jcl.amount) AS cost_total
    FROM job_cost_ledger jcl
    WHERE jcl.job = $1
      AND jcl.transaction_type IN ('AP cost', 'JC cost', 'PR cost')
      AND jcl.transaction_date IS NOT NULL
    GROUP BY DATE_TRUNC('month', jcl.transaction_date)
),
monthly_billed AS (
    SELECT
        DATE_TRUNC('month', jcl.transaction_date)::DATE AS month,
        SUM(jcl.amount) AS billed_total
    FROM job_cost_ledger jcl
    WHERE jcl.job = $1
      AND jcl.transaction_type = 'work billed'
      AND jcl.transaction_date IS NOT NULL
    GROUP BY DATE_TRUNC('month', jcl.transaction_date)
    HAVING SUM(jcl.amount) > 0
)
SELECT
    mb.month,
    COALESCE((
        SELECT SUM(mc.cost_total)
        FROM monthly_costs mc
        WHERE mc.month <= mb.month
    ), 0)::BIGINT AS cost_total,
    mb.billed_total::BIGINT AS pay_app_total,
    COALESCE((
        SELECT SUM(mc.cost_total)
        FROM monthly_costs mc
        WHERE mc.month <= mb.month
    ), 0)::BIGINT AS cumulative_cost,
    SUM(mb.billed_total) OVER (ORDER BY mb.month)::BIGINT AS cumulative_pay_app
FROM monthly_billed mb
ORDER BY mb.month
`

type GetMonthlyPerformanceRow struct {
	Month            time.Time `json:"month"`
	CostTotal        int64     `json:"cost_total"`
	PayAppTotal      int64     `json:"pay_app_total"`
	CumulativeCost   int64     `json:"cumulative_cost"`
	CumulativePayApp int64     `json:"cumulative_pay_app"`
}

// Fetches monthly cost and billed totals for a job from job_cost_ledger
// Costs = AP cost, JC cost, PR cost; Billed = work billed
func (q *Queries) GetMonthlyPerformance(ctx context.Context, job string) ([]GetMonthlyPerformanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyPerformance, job)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonthlyPerformanceRow
	for rows.Next() {
		var i GetMonthlyPerformanceRow
		if err := rows.Scan(
			&i.Month,
			&i.CostTotal,
			&i.PayAppTotal,
			&i.CumulativeCost,
			&i.CumulativePayApp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOverBudgetPhases = `-- name: GetOverBudgetPhases :many
WITH phase_costs AS (
    SELECT
        jcl.phase,
        SUM(jcl.amount) AS actual_cost
    FROM job_cost_ledger jcl
    WHERE jcl.job = $1
      AND jcl.transaction_type IN ('AP cost', 'JC cost', 'PR cost')
    GROUP BY jcl.phase
),
phase_budgets AS (
    SELECT
        jcl.phase,
        SUM(jcl.amount) AS budget
    FROM job_cost_ledger jcl
    WHERE jcl.job = $1
      AND jcl.transaction_type = 'Original estimate'
    GROUP BY jcl.phase
),
phase_descriptions AS (
    SELECT
        ji.job_cost_id AS phase,
        STRING_AGG(DISTINCT ji.description, ', ') AS descriptions
    FROM job_items ji
    WHERE ji.job_id = (SELECT j.id FROM jobs j WHERE j.job_number = $1)
      AND ji.job_cost_id IS NOT NULL
    GROUP BY ji.job_cost_id
)
SELECT
    COALESCE(pb.phase, pc.phase) AS phase,
    COALESCE(pd.descriptions, '') AS description,
    COALESCE(pb.budget, 0)::BIGINT AS budget,
    COALESCE(pc.actual_cost, 0)::BIGINT AS actual_cost,
    (COALESCE(pc.actual_cost, 0) - COALESCE(pb.budget, 0))::BIGINT AS variance
FROM phase_budgets pb
FULL OUTER JOIN phase_costs pc ON pb.phase = pc.phase
LEFT JOIN phase_descriptions pd ON COALESCE(pb.phase, pc.phase) = pd.phase
WHERE COALESCE(pc.actual_cost, 0) > COALESCE(pb.budget, 0)
ORDER BY (COALESCE(pc.actual_cost, 0) - COALESCE(pb.budget, 0)) DESC
`

type GetOverBudgetPhasesRow struct {
	Phase       sql.NullString `json:"phase"`
	Description []byte         `json:"description"`
	Budget      int64          `json:"budget"`
	ActualCost  int64          `json:"actual_cost"`
	Variance    int64          `json:"variance"`
}

// Fetches phase codes where actual costs exceed budget
// Uses "Original estimate" from job_cost_ledger as the budget source
func (q *Queries) GetOverBudgetPhases(ctx context.Context, job string) ([]GetOverBudgetPhasesRow, error) {
	rows, err := q.db.QueryContext(ctx, getOverBudgetPhases, job)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOverBudgetPhasesRow
	for rows.Next() {
		var i GetOverBudgetPhasesRow
		if err := rows.Scan(
			&i.Phase,
			&i.Description,
			&i.Budget,
			&i.ActualCost,
			&i.Variance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParentItems = `-- name: GetParentItems :many
SELECT DISTINCT ji.id, ji.item_number, ji.description, ji.budget, ji.qty, ji.unit_price
FROM job_items ji
WHERE ji.job_id = $1
  AND EXISTS (SELECT 1 FROM job_items child WHERE child.parent_id = ji.id)
`

type GetParentItemsRow struct {
	ID          uuid.UUID `json:"id"`
	ItemNumber  string    `json:"item_number"`
	Description string    `json:"description"`
	Budget      string    `json:"budget"`
	Qty         string    `json:"qty"`
	UnitPrice   string    `json:"unit_price"`
}

// Fetches all parent items (items that have children) for a job
func (q *Queries) GetParentItems(ctx context.Context, jobID uuid.UUID) ([]GetParentItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getParentItems, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetParentItemsRow
	for rows.Next() {
		var i GetParentItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.ItemNumber,
			&i.Description,
			&i.Budget,
			&i.Qty,
			&i.UnitPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParentPayAppForMonth = `-- name: GetParentPayAppForMonth :one
SELECT
    pa.qty,
    pac.cumulative_qty::TEXT AS cumulative_qty,
    pac.previous_cumulative_qty::TEXT AS previous_cumulative_qty,
    ji.qty AS total_qty,
    ji.unit_price
FROM pay_applications pa
JOIN job_items ji ON pa.job_item_id = ji.id
LEFT JOIN pay_application_cumulative pac ON pa.job_item_id = pac.job_item_id AND pa.pay_app_month = pac.pay_app_month
WHERE pa.job_item_id = $1 AND pa.pay_app_month = $2
`

type GetParentPayAppForMonthParams struct {
	JobItemID   uuid.UUID `json:"job_item_id"`
	PayAppMonth time.Time `json:"pay_app_month"`
}

type GetParentPayAppForMonthRow struct {
	Qty                   string `json:"qty"`
	CumulativeQty         string `json:"cumulative_qty"`
	PreviousCumulativeQty string `json:"previous_cumulative_qty"`
	TotalQty              string `json:"total_qty"`
	UnitPrice             string `json:"unit_price"`
}

// Gets a parent's pay application data for a specific month
func (q *Queries) GetParentPayAppForMonth(ctx context.Context, arg GetParentPayAppForMonthParams) (GetParentPayAppForMonthRow, error) {
	row := q.db.QueryRowContext(ctx, getParentPayAppForMonth, arg.JobItemID, arg.PayAppMonth)
	var i GetParentPayAppForMonthRow
	err := row.Scan(
		&i.Qty,
		&i.CumulativeQty,
		&i.PreviousCumulativeQty,
		&i.TotalQty,
		&i.UnitPrice,
	)
	return i, err
}

const getPayAppCumulative = `-- name: GetPayAppCumulative :many
SELECT
    job_item_id,
    pay_app_month,
    job_id,
    parent_id,
    this_month_qty,
    stored_materials,
    total_qty,
    unit_price,
    budget,
    cumulative_qty,
    previous_cumulative_qty,
    remaining_qty,
    percent_complete,
    this_month_amount,
    cumulative_amount,
    previous_cumulative_amount
FROM pay_application_cumulative
WHERE job_id = $1 AND pay_app_month = $2
`

type GetPayAppCumulativeParams struct {
	JobID       uuid.UUID `json:"job_id"`
	PayAppMonth time.Time `json:"pay_app_month"`
}

// Fetches cumulative pay application data for a job and specific month
func (q *Queries) GetPayAppCumulative(ctx context.Context, arg GetPayAppCumulativeParams) ([]PayApplicationCumulative, error) {
	rows, err := q.db.QueryContext(ctx, getPayAppCumulative, arg.JobID, arg.PayAppMonth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PayApplicationCumulative
	for rows.Next() {
		var i PayApplicationCumulative
		if err := rows.Scan(
			&i.JobItemID,
			&i.PayAppMonth,
			&i.JobID,
			&i.ParentID,
			&i.ThisMonthQty,
			&i.StoredMaterials,
			&i.TotalQty,
			&i.UnitPrice,
			&i.Budget,
			&i.CumulativeQty,
			&i.PreviousCumulativeQty,
			&i.RemainingQty,
			&i.PercentComplete,
			&i.ThisMonthAmount,
			&i.CumulativeAmount,
			&i.PreviousCumulativeAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPayAppMonthsForJob = `-- name: GetPayAppMonthsForJob :many
SELECT DISTINCT pa.pay_app_month
FROM pay_applications pa
JOIN job_items ji ON pa.job_item_id = ji.id
WHERE ji.job_id = $1
ORDER BY pa.pay_app_month
`

// Gets all distinct months with pay applications for a job
func (q *Queries) GetPayAppMonthsForJob(ctx context.Context, jobID uuid.UUID) ([]time.Time, error) {
	rows, err := q.db.QueryContext(ctx, getPayAppMonthsForJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var pay_app_month time.Time
		if err := rows.Scan(&pay_app_month); err != nil {
			return nil, err
		}
		items = append(items, pay_app_month)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertJobCostLedger = `-- name: InsertJobCostLedger :exec
INSERT INTO job_cost_ledger (
    id, job, phase, cat, transaction_type, transaction_date, amount
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
ON CONFLICT (id) DO NOTHING
`

type InsertJobCostLedgerParams struct {
	ID              string         `json:"id"`
	Job             string         `json:"job"`
	Phase           sql.NullString `json:"phase"`
	Cat             sql.NullString `json:"cat"`
	TransactionType sql.NullString `json:"transaction_type"`
	TransactionDate sql.NullTime   `json:"transaction_date"`
	Amount          string         `json:"amount"`
}

// Inserts a job cost ledger entry, skips if hash already exists
func (q *Queries) InsertJobCostLedger(ctx context.Context, arg InsertJobCostLedgerParams) error {
	_, err := q.db.ExecContext(ctx, insertJobCostLedger,
		arg.ID,
		arg.Job,
		arg.Phase,
		arg.Cat,
		arg.TransactionType,
		arg.TransactionDate,
		arg.Amount,
	)
	return err
}

const insertPayApplicationIfNotExists = `-- name: InsertPayApplicationIfNotExists :exec
INSERT INTO pay_applications (
    job_item_id, pay_app_month, qty, stored_materials
) VALUES (
    $1, $2, $3, $4
)
ON CONFLICT (job_item_id, pay_app_month) DO NOTHING
`

type InsertPayApplicationIfNotExistsParams struct {
	JobItemID       uuid.UUID `json:"job_item_id"`
	PayAppMonth     time.Time `json:"pay_app_month"`
	Qty             string    `json:"qty"`
	StoredMaterials string    `json:"stored_materials"`
}

// Inserts pay application data only if no record exists for this item/month
func (q *Queries) InsertPayApplicationIfNotExists(ctx context.Context, arg InsertPayApplicationIfNotExistsParams) error {
	_, err := q.db.ExecContext(ctx, insertPayApplicationIfNotExists,
		arg.JobItemID,
		arg.PayAppMonth,
		arg.Qty,
		arg.StoredMaterials,
	)
	return err
}

const updateStoredMaterials = `-- name: UpdateStoredMaterials :exec
UPDATE pay_applications
SET stored_materials = $3, updated_at = NOW()
WHERE job_item_id = $1 AND pay_app_month = $2
`

type UpdateStoredMaterialsParams struct {
	JobItemID       uuid.UUID `json:"job_item_id"`
	PayAppMonth     time.Time `json:"pay_app_month"`
	StoredMaterials string    `json:"stored_materials"`
}

// Updates only the stored_materials field for an existing pay application
func (q *Queries) UpdateStoredMaterials(ctx context.Context, arg UpdateStoredMaterialsParams) error {
	_, err := q.db.ExecContext(ctx, updateStoredMaterials, arg.JobItemID, arg.PayAppMonth, arg.StoredMaterials)
	return err
}

const upsertJob = `-- name: UpsertJob :one
INSERT INTO jobs (
    job_number, job_name, contract_value, address, 
    scr_number, contract_complete_date, start_date, end_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
ON CONFLICT (job_number) 
DO UPDATE SET 
    job_name = EXCLUDED.job_name,
    contract_value = EXCLUDED.contract_value,
    address = EXCLUDED.address,
    scr_number = EXCLUDED.scr_number,
    contract_complete_date = EXCLUDED.contract_complete_date,
    start_date = EXCLUDED.start_date,
    end_date = EXCLUDED.end_date,
    updated_at = NOW()
RETURNING id
`

type UpsertJobParams struct {
	JobNumber            string         `json:"job_number"`
	JobName              string         `json:"job_name"`
	ContractValue        sql.NullString `json:"contract_value"`
	Address              sql.NullString `json:"address"`
	ScrNumber            sql.NullString `json:"scr_number"`
	ContractCompleteDate sql.NullTime   `json:"contract_complete_date"`
	StartDate            sql.NullTime   `json:"start_date"`
	EndDate              sql.NullTime   `json:"end_date"`
}

func (q *Queries) UpsertJob(ctx context.Context, arg UpsertJobParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, upsertJob,
		arg.JobNumber,
		arg.JobName,
		arg.ContractValue,
		arg.Address,
		arg.ScrNumber,
		arg.ContractCompleteDate,
		arg.StartDate,
		arg.EndDate,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const upsertJobItem = `-- name: UpsertJobItem :one
INSERT INTO job_items (
    job_id, parent_id, sort_order, item_number, description, 
    scheduled_value, job_cost_id, budget, qty, unit, unit_price
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
ON CONFLICT (job_id, item_number)
DO UPDATE SET 
    parent_id = EXCLUDED.parent_id,
    sort_order = EXCLUDED.sort_order,
    description = EXCLUDED.description,
    scheduled_value = EXCLUDED.scheduled_value,
    job_cost_id = EXCLUDED.job_cost_id,
    budget = EXCLUDED.budget,
    qty = EXCLUDED.qty,
    unit = EXCLUDED.unit,
    unit_price = EXCLUDED.unit_price,
    updated_at = NOW()
RETURNING id
`

type UpsertJobItemParams struct {
	JobID          uuid.UUID      `json:"job_id"`
	ParentID       uuid.NullUUID  `json:"parent_id"`
	SortOrder      int32          `json:"sort_order"`
	ItemNumber     string         `json:"item_number"`
	Description    string         `json:"description"`
	ScheduledValue string         `json:"scheduled_value"`
	JobCostID      sql.NullString `json:"job_cost_id"`
	Budget         string         `json:"budget"`
	Qty            string         `json:"qty"`
	Unit           sql.NullString `json:"unit"`
	UnitPrice      string         `json:"unit_price"`
}

func (q *Queries) UpsertJobItem(ctx context.Context, arg UpsertJobItemParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, upsertJobItem,
		arg.JobID,
		arg.ParentID,
		arg.SortOrder,
		arg.ItemNumber,
		arg.Description,
		arg.ScheduledValue,
		arg.JobCostID,
		arg.Budget,
		arg.Qty,
		arg.Unit,
		arg.UnitPrice,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const upsertPayApplication = `-- name: UpsertPayApplication :exec
INSERT INTO pay_applications (
    job_item_id, pay_app_month, qty, stored_materials
) VALUES (
    $1, $2, $3, $4
)
ON CONFLICT (job_item_id, pay_app_month)
DO UPDATE SET
    qty = EXCLUDED.qty,
    stored_materials = EXCLUDED.stored_materials,
    updated_at = NOW()
`

type UpsertPayApplicationParams struct {
	JobItemID       uuid.UUID `json:"job_item_id"`
	PayAppMonth     time.Time `json:"pay_app_month"`
	Qty             string    `json:"qty"`
	StoredMaterials string    `json:"stored_materials"`
}

func (q *Queries) UpsertPayApplication(ctx context.Context, arg UpsertPayApplicationParams) error {
	_, err := q.db.ExecContext(ctx, upsertPayApplication,
		arg.JobItemID,
		arg.PayAppMonth,
		arg.Qty,
		arg.StoredMaterials,
	)
	return err
}
