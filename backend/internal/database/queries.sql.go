// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const deleteJobItemsByJob = `-- name: DeleteJobItemsByJob :exec
DELETE FROM job_items WHERE job_id = $1
`

func (q *Queries) DeleteJobItemsByJob(ctx context.Context, jobID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteJobItemsByJob, jobID)
	return err
}

const getJobByNumber = `-- name: GetJobByNumber :one
SELECT id, job_number, job_name FROM jobs WHERE job_number = $1
`

type GetJobByNumberRow struct {
	ID        uuid.UUID `json:"id"`
	JobNumber string    `json:"job_number"`
	JobName   string    `json:"job_name"`
}

func (q *Queries) GetJobByNumber(ctx context.Context, jobNumber string) (GetJobByNumberRow, error) {
	row := q.db.QueryRowContext(ctx, getJobByNumber, jobNumber)
	var i GetJobByNumberRow
	err := row.Scan(&i.ID, &i.JobNumber, &i.JobName)
	return i, err
}

const getJobTree = `-- name: GetJobTree :many
WITH RECURSIVE job_tree AS (
    -- 1. Anchor: Select Roots (Items with no parent)
    -- We alias the table as 'root' to prevent ambiguity errors
    SELECT 
        root.id, 
        root.job_id, 
        root.parent_id, 
        root.sort_order, 
        root.item_number, 
        root.description,
        root.scheduled_value, 
        root.budget, 
        root.job_cost_id, 
        root.qty, 
        root.unit, 
        root.unit_price,
        1 AS depth,
        ARRAY[root.sort_order] AS path_order
    FROM job_items root
    WHERE root.job_id = $1 AND root.parent_id IS NULL

    UNION ALL

    -- 2. Recursion: Join Children to Parents
    SELECT 
        c.id, 
        c.job_id, 
        c.parent_id, 
        c.sort_order, 
        c.item_number, 
        c.description,
        c.scheduled_value, 
        c.budget, 
        c.job_cost_id, 
        c.qty, 
        c.unit, 
        c.unit_price,
        p.depth + 1,
        p.path_order || c.sort_order
    FROM job_items c
    JOIN job_tree p ON c.parent_id = p.id
)
SELECT id, job_id, parent_id, sort_order, item_number, description, scheduled_value, budget, job_cost_id, qty, unit, unit_price, depth, path_order FROM job_tree
ORDER BY path_order
`

type GetJobTreeRow struct {
	ID             uuid.UUID      `json:"id"`
	JobID          uuid.UUID      `json:"job_id"`
	ParentID       uuid.NullUUID  `json:"parent_id"`
	SortOrder      int32          `json:"sort_order"`
	ItemNumber     string         `json:"item_number"`
	Description    string         `json:"description"`
	ScheduledValue string         `json:"scheduled_value"`
	Budget         string         `json:"budget"`
	JobCostID      sql.NullString `json:"job_cost_id"`
	Qty            string         `json:"qty"`
	Unit           sql.NullString `json:"unit"`
	UnitPrice      string         `json:"unit_price"`
	Depth          int32          `json:"depth"`
	PathOrder      interface{}    `json:"path_order"`
}

// 3. Sort by the array path to recreate Excel structure
func (q *Queries) GetJobTree(ctx context.Context, jobID uuid.UUID) ([]GetJobTreeRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobTree, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobTreeRow
	for rows.Next() {
		var i GetJobTreeRow
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.ParentID,
			&i.SortOrder,
			&i.ItemNumber,
			&i.Description,
			&i.ScheduledValue,
			&i.Budget,
			&i.JobCostID,
			&i.Qty,
			&i.Unit,
			&i.UnitPrice,
			&i.Depth,
			&i.PathOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertJob = `-- name: UpsertJob :one
INSERT INTO jobs (
    job_number, job_name, contract_value, address, 
    scr_number, contract_complete_date, start_date, end_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
ON CONFLICT (job_number) 
DO UPDATE SET 
    job_name = EXCLUDED.job_name,
    contract_value = EXCLUDED.contract_value,
    address = EXCLUDED.address,
    scr_number = EXCLUDED.scr_number,
    contract_complete_date = EXCLUDED.contract_complete_date,
    start_date = EXCLUDED.start_date,
    end_date = EXCLUDED.end_date,
    updated_at = NOW()
RETURNING id
`

type UpsertJobParams struct {
	JobNumber            string         `json:"job_number"`
	JobName              string         `json:"job_name"`
	ContractValue        sql.NullString `json:"contract_value"`
	Address              sql.NullString `json:"address"`
	ScrNumber            sql.NullString `json:"scr_number"`
	ContractCompleteDate sql.NullTime   `json:"contract_complete_date"`
	StartDate            sql.NullTime   `json:"start_date"`
	EndDate              sql.NullTime   `json:"end_date"`
}

func (q *Queries) UpsertJob(ctx context.Context, arg UpsertJobParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, upsertJob,
		arg.JobNumber,
		arg.JobName,
		arg.ContractValue,
		arg.Address,
		arg.ScrNumber,
		arg.ContractCompleteDate,
		arg.StartDate,
		arg.EndDate,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const upsertJobItem = `-- name: UpsertJobItem :one
INSERT INTO job_items (
    job_id, parent_id, sort_order, item_number, description, 
    scheduled_value, job_cost_id, budget, qty, unit, unit_price
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
ON CONFLICT (job_id, item_number)
DO UPDATE SET 
    parent_id = EXCLUDED.parent_id,
    sort_order = EXCLUDED.sort_order,
    description = EXCLUDED.description,
    scheduled_value = EXCLUDED.scheduled_value,
    job_cost_id = EXCLUDED.job_cost_id,
    budget = EXCLUDED.budget,
    qty = EXCLUDED.qty,
    unit = EXCLUDED.unit,
    unit_price = EXCLUDED.unit_price,
    updated_at = NOW()
RETURNING id
`

type UpsertJobItemParams struct {
	JobID          uuid.UUID      `json:"job_id"`
	ParentID       uuid.NullUUID  `json:"parent_id"`
	SortOrder      int32          `json:"sort_order"`
	ItemNumber     string         `json:"item_number"`
	Description    string         `json:"description"`
	ScheduledValue string         `json:"scheduled_value"`
	JobCostID      sql.NullString `json:"job_cost_id"`
	Budget         string         `json:"budget"`
	Qty            string         `json:"qty"`
	Unit           sql.NullString `json:"unit"`
	UnitPrice      string         `json:"unit_price"`
}

func (q *Queries) UpsertJobItem(ctx context.Context, arg UpsertJobItemParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, upsertJobItem,
		arg.JobID,
		arg.ParentID,
		arg.SortOrder,
		arg.ItemNumber,
		arg.Description,
		arg.ScheduledValue,
		arg.JobCostID,
		arg.Budget,
		arg.Qty,
		arg.Unit,
		arg.UnitPrice,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const upsertPayApplication = `-- name: UpsertPayApplication :exec
INSERT INTO pay_applications (
    job_item_id, pay_app_month, qty, stored_materials
) VALUES (
    $1, $2, $3, $4
)
ON CONFLICT (job_item_id, pay_app_month)
DO UPDATE SET 
    qty = EXCLUDED.qty,
    stored_materials = EXCLUDED.stored_materials,
    updated_at = NOW()
`

type UpsertPayApplicationParams struct {
	JobItemID       uuid.UUID `json:"job_item_id"`
	PayAppMonth     time.Time `json:"pay_app_month"`
	Qty             string    `json:"qty"`
	StoredMaterials string    `json:"stored_materials"`
}

func (q *Queries) UpsertPayApplication(ctx context.Context, arg UpsertPayApplicationParams) error {
	_, err := q.db.ExecContext(ctx, upsertPayApplication,
		arg.JobItemID,
		arg.PayAppMonth,
		arg.Qty,
		arg.StoredMaterials,
	)
	return err
}
